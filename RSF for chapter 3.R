library(readxl)
library(leaflet)
library(rgdal)
library(raster)
library(maptools)
library(ggplot2)
library(sf)
library(terra)
library(survival)
library(mgcv)

setwd('C:\\Users\\Lorenzo\\OneDrive - Stellenbosch University\\LorenzosProject\\Chapter 3')

(geo = '+proj=longlat +datum=WGS84 +no_defs') # Unprojected world Geodetic System (degrees) CRS("+init=epsg:4326")
Krugershape=readOGR('boundary_kruger_H7_south_geo.shp')# To see whether our points lie inside KNP or not


#census <- read_excel("rhino_census_sample_geo_krugerSouth_1998_to_2008_2010_2012_2014_2016.xlsx")
#dead<-readShapeSpatial("rhino_dead_geo_krugerSouth_2007_to_2017.shp")
dead= rgdal::readOGR("rhino_dead_geo_krugerSouth_2007_to_2017.shp")
d_df=as.data.frame(dead)
#census1=readShapeSpatial("rhino_census_sample_geo_krugerSouth_1998_to_2008_2010_2012_2014_2016.shp")
#plot(census1)
plot(dead)
plot(Krugershape)
head(dead@data)
unique(dead@data$Species)
dead_white=dead[dead$Species=="White",]
dw_df=as.data.frame(dead_white)
plot(dead_white)
plot(Krugershape, add=T)

library(ggplot2)
# counts
histdead = ggplot(data.frame(dw_df), aes(x=dw_df$Method)) +
  geom_bar() + xlab("Status") + ylab("Frequency") + labs(title="Frequency of the White Rhino carcasses's status")
histdead


unique(dw_df$Method)
dw_i=dw_df[dw_df$Method=="Inconclusive",]
dw_s=dw_df[dw_df$Method=="Shot",]
dw_u=dw_df[dw_df$Method=="Unknown",]
dw_w=dw_df[dw_df$Method=="Wounded",]

Differentyears=data.frame()
for (i in 1:nrow(dw_df)){
  if ((dw_df[i,]$Year!=dw_df[i,]$YearDied)){
    Differentyears=rbind(Differentyears,dw_df[i,])
  }
  else{
    i=i+1
  }
}
(Differentyears)

dw_df_yd=dw_df
for (i in 1:nrow(dw_df)){
  if (dw_df[i,]$YearDied==0){
    dw_df_yd[i,]$YearDied=dw_df_yd[i,]$Year
  }
  else{
    i=i+1
  }
}

Differentyears1=data.frame()
for (i in 1:nrow(dw_df_yd)){
  if ((dw_df_yd[i,]$Year!=dw_df_yd[i,]$YearDied)){
    Differentyears1=rbind(Differentyears1,dw_df_yd[i,])
  }
  else{
    i=i+1
  }
}
(Differentyears1)

histdeadperyeardead = ggplot(data.frame(dw_df_yd), aes(x=dw_df_yd$YearDied)) +
  geom_bar() + xlab("Years (died)") + ylab("Count") + labs(title="Frequency of the White Rhino carcasses per year")
histdeadperyeardead


#Generate random points for each death (We generate 5 points and we will run the clogit with different number of points)

#We generate the column of stratum and used

stratum=c()
used=c()
for (i in 1:nrow(dw_df_yd)){
  used[i]=1
  stratum[i]=i
}
dw_df_yd=cbind(dw_df_yd, used, stratum)


#We generate the random points with latitude and longitude extracted from a uniform distribution bounded between the max and min latitude and longitude
#of the portion of KNP we are working with. Were the points to fall outside the frame, both the coordinates will be extracted again from the same 
#distributions. The process is to be repeated until the point will fall within the KNP.

Krugershape
n.pseudo=2 #setting the number of random points generated
dw_df_yd_a=dw_df_yd
pippo=0
for(i in 1:nrow(dw_df_yd))#We generate the random points
{
  #Z.null[i,] <-Z1[i] + sample(na.omit(RelSteps),n.pseudo) * Rotate[i] #Rotate (with RelSteps) is used to "randomize"
  #the angles (otherwise their sides will be parallel)
  #dw_df_yd_a[i,]=dw_s
  
  for(j in 1:n.pseudo)#We discard the random steps that lay outside KNP borders
  {
    dw_df_yd_a[(i-1)*n.pseudo+j,]=dw_df_yd[i,]
    dw_df_yd_a[(i-1)*n.pseudo+j,]$used=0
    lon=runif(1,raster::xmin(Krugershape),raster::xmax(Krugershape))
    lat=runif(1,raster::ymin(Krugershape),raster::ymax(Krugershape))
    dw_df_yd_a[(i-1)*n.pseudo+j,8]=lon
    dw_df_yd_a[(i-1)*n.pseudo+j,10]=lon
    dw_df_yd_a[(i-1)*n.pseudo+j,9]=lat
    dw_df_yd_a[(i-1)*n.pseudo+j,11]=lat
    mydf=structure(list(longitude=lon,latitude=lat, .Names=c("longitude","latitude"), class="data.frame", row.names=c(NA, -1L)))
    xy=mydf[c(1,2)] 
    spdf=SpatialPoints(coords=xy,proj4string=CRS('+proj=longlat +datum=WGS84 +no_defs'))
    while(length(spdf[Krugershape,])==0)
    {
      pippo=pippo+1
      dw_df_yd_a[(i-1)*n.pseudo+j,]=dw_df_yd[i,]
      dw_df_yd_a[(i-1)*n.pseudo+j,]$used=0
      lon=runif(1,raster::xmin(Krugershape),raster::xmax(Krugershape))
      lat=runif(1,raster::ymin(Krugershape),raster::ymax(Krugershape))
      dw_df_yd_a[(i-1)*n.pseudo+j,8]=lon
      dw_df_yd_a[(i-1)*n.pseudo+j,10]=lon
      dw_df_yd_a[(i-1)*n.pseudo+j,9]=lat
      dw_df_yd_a[(i-1)*n.pseudo+j,11]=lat
      #Z.null[i,j] <-Z1[i] + sample(na.omit(RelSteps),1) * Rotate[i]
      #Z.null is generated by taking the i-th point from newdata4 applying its corresponding angle Phi (Rotate is a one unit length 
      #vector which sets Z1[i] to its "real" path) and then adding a random selected step out of all the availables
      mydf=structure(list(longitude=c(lon),latitude=c(lat), .Names=c("longitude","latitude"), class="data.frame", row.names=c(NA, -1L)))
      xy=mydf[c(1,2)] 
      spdf=SpatialPoints(coords=xy,proj4string=CRS('+proj=longlat +datum=WGS84 +no_defs'))
    }
    #plot(spdf,add=T)
  }
}

plot(dw_df_yd$POINT_X, dw_df_yd$POINT_Y)
plot(main="Random points for the year 2012",dw_df_yd_a[dw_df_yd_a$Year==2012,]$POINT_X,dw_df_yd_a[dw_df_yd_a$Year==2012,]$POINT_Y, 
     xlab= "Longitude",
     ylab= "Latitude",pch = 20)

plot(Krugershape, add=T)

#ggplot for the random points

library(ggplot2)
library(sf)

rpoints_2012 <- subset(dw_df_yd_a, Year == 2012)

ggplot() +
  geom_sf(data = Krugershape_sf, fill = NA, color = "black") +
  geom_point(data = rpoints_2012, 
             aes(x = POINT_X, y = POINT_Y), 
             color = "blue", size = 1) +
  labs(title = "Random points for the year 2012",
       x = "Longitude", y = "Latitude") +
  theme_minimal() +
  coord_sf()




plot(
  main="Random points per year",
  x=dw_df_yd_a$POINT_X,
  y=dw_df_yd_a$POINT_Y,
  xlab= "Longitude",
  ylab= "Latitude",
  pch = 20,
  col=1:length(unique(dw_df_yd_a$Year))
)

plot(Krugershape, add=T)

legend(
  x ="topleft",
  legend = ordered(unique(dw_df_yd_a$YearDied)), # for readability of legend
  col = 1:length(unique(dw_df_yd_a$YearDied)),
  pch = 19, # same as pch=20, just smaller
  cex = .7 # scale the legend to look attractively sized
)


#ggplot for all the random points

ggplot() +
  geom_sf(data = Krugershape_sf, fill = NA, color = "black") +
  geom_point(data = dw_df_yd_a, 
             aes(x = POINT_X, y = POINT_Y, color = as.factor(YearDied)), 
             size = 1.5, alpha = 0.8) +
  scale_color_manual(values = 1:length(unique(dw_df_yd_a$YearDied))) +  # or use scale_color_manual() for custom
  labs(title = "Random points per year", 
       x = "Longitude", 
       y = "Latitude",
       color = "Year") +
  coord_sf() +
  theme_minimal()




dw_2=rbind(dw_df_yd,dw_df_yd_a)


# Load RasterStack
(enviroStack = stack('newEnviroStack_geo.tif'))
# Correct the layer names
names(enviroStack) = (read.csv('newEnviroStack_geo_names.csv'))[,'x']
names(enviroStack)
# Convert data.frame to SpatialPointsDataFrame
knpData.pts = dw_2
coordinates(knpData.pts) = ~POINT_X + POINT_Y
# Extract raster value by points
ThreeVar=stack(enviroStack[[1]],enviroStack[[2]],enviroStack[[3]]) #distrivers, distroads, elevation
rasValue.2km = raster::extract(ThreeVar, knpData.pts)
dw_2v=cbind(dw_2, rasValue.2km)

Edistr <- raster("Edist.tif")
WnoPdistr<- raster("WnoPdist.tif")
WPdistr<- raster("WPdist.tif")
Sdistr<- raster("Sdist.tif")
Borderdist=stack(Edistr, WnoPdistr, WPdistr, Sdistr)
Borderdistextr=raster::extract(Borderdist, knpData.pts)

dw_2v=cbind(dw_2v, Borderdistextr)

#to add other environmental variables (namely evi of the different years and slope)
names(enviroStack)
slopenevivar=stack(enviroStack[[7]], enviroStack[[35]],enviroStack[[36]],enviroStack[[37]],enviroStack[[38]],
                   enviroStack[[39]],enviroStack[[40]],enviroStack[[41]],enviroStack[[42]],enviroStack[[43]],
                   enviroStack[[44]], enviroStack[[45]])
rasValue.2km1 =raster::extract(slopenevivar, knpData.pts)
dw_2=cbind(dw_2v,rasValue.2km1)


rclg_stack <- stack(ThreeVar, WnoPdistr, WPdistr, Sdistr, slopenevivar)

# Convert to data frame
grid_df_raw <- as.data.frame(rclg_stack, xy = TRUE, na.rm = TRUE)

# Rename columns to match your variable names
#names(grid_df_raw) <- c("x", "y", "distRivers", "distRoads", "elevation", "WnoPdist", "WPdist", "Sdist")


for (i in 1:nrow(grid_df_raw)){
  if (grid_df_raw[i,]$distRivers<0){
    grid_df_raw[i,]$distRivers=0
  }
  if (grid_df_raw[i,]$distRoads<0){
    grid_df_raw[i,]$distRoads=0
  }
}


#Clogit

#dead_white_2010n=dw_n1[dw_n1$Year<=2010,] #Problems for building the layers, since we have different years
dead_white_20112=dw_2[dw_2$YearDied==2011,]
dead_white_20122=dw_2[dw_2$YearDied==2012,]
dead_white_20132=dw_2[dw_2$YearDied==2013,]
dead_white_20142=dw_2[dw_2$YearDied==2014,]
dead_white_20152=dw_2[dw_2$YearDied==2015,]
dead_white_20162=dw_2[dw_2$YearDied==2016,]
dead_white_20172=dw_2[dw_2$YearDied==2017,]

#2011
d11nnona=na.omit(dead_white_20112)
d11= clogit(used ~distRivers + distRoads 
            + elevation 
            #+ Edist 
            + WnoPdist
            + WPdist + Sdist
            + slope
            + evi2011
            #+ strata(stratum)
            , method = "approximate"
            ,data = d11nnona,
            na.action = "na.fail")
summary(d11)


vif11=car::vif(d11)
vif11

#heatmap
grid_df11 <- grid_df_raw
head(grid_df11)
summary(d2011)
grid_df11$linear_predictor <- with(grid_df_raw,  #only include the significant ones
                                   coefs11["distRivers"] * distRivers +
                                     coefs11["distRoads"]  * distRoads +
                                     coefs11["elevation"]  * elevation +
                                     coefs11["WnoPdist"] * WnoPdist
                                   +coefs11["WPdist"] * WPdist 
                                   +coefs11["Sdist"] *Sdist
                                   +coefs11["slope"]*slope+
                                     +coefs11["evi2011"]*evi2011
)

vc <- vcov(d2011)                  # variance-covariance matrix
coefs <- coef(d2011)               # coefficient estimates

Xmat <- model.matrix(~ distRivers + distRoads + elevation + WnoPdist
                     + WPdist + Sdist
                     + slope
                     + evi2011- 1, 
                     data = grid_df11)

# predicted linear predictor
lp <- Xmat %*% coefs[c("distRivers","distRoads","elevation","slope", "WnoPdist", "WPdist","Sdist", "evi2011" )]

# standard errors of predictions
lp_se <- sqrt(rowSums((Xmat %*% vc[c("distRivers","distRoads","elevation","slope", "WnoPdist", "WPdist","Sdist", "evi2011"),
                                   c("distRivers","distRoads","elevation","slope", "WnoPdist", "WPdist","Sdist", "evi2011")] ) * Xmat))


# 95% CI on linear predictor
lp_lower <- lp - 1.96 * lp_se
lp_upper <- lp + 1.96 * lp_se

# Transform to relative selection scale
grid_df11$rel_sel <- plogis(lp)
grid_df11$rel_sel_lower <- plogis(lp_lower)
grid_df11$rel_sel_upper <- plogis(lp_upper)

grid_df11$rel_sel_ci_width <- grid_df11$rel_sel_upper - grid_df11$rel_sel_lower

r11_sel <- rasterFromXYZ(grid_df11[, c("x", "y", "rel_sel")])
r11_ci_width <- rasterFromXYZ(grid_df11[, c("x", "y", "rel_sel_ci_width")])

r11_sel_crop <- raster::crop(r11_sel, Krugershape)
r11_ci_width_crop <- raster::crop(r11_ci_width, Krugershape)

# Mask the raster so only inside the polygon is kept
r11_sel_masked <- raster::mask(r11_sel_crop, Krugershape)
r11_ci_width_masked <- raster::mask(r11_ci_width_crop, Krugershape)

r11_sel_df <- as.data.frame(r11_sel_masked, xy = TRUE)
names(r11_sel_df)[3] <- "rel_sel"
r11_ci_width_df <- as.data.frame(r11_ci_width_masked, xy = TRUE)
names(r11_ci_width_df)[3] <- "CI width"

# Mean relative selection
p1 <- ggplot(r11_sel_df, aes(x = x, y = y, fill = rel_sel)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection") +
  coord_equal() +
  theme_minimal()

# Uncertainty (CI width)
p2 <- ggplot(r11_ci_width_df, aes(x = x, y = y, fill = rel_sel_ci_width)) +
  geom_raster() +
  scale_fill_viridis_c(name = "95% CI Width") +
  coord_equal() +
  theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2,  ncol = 2)









predict_rsf_with_ci <- function(model, grid_df, vars, shape, conf_level = 0.95) {
  # Extract coefficients and covariance
  coefs <- coef(model)
  vc <- vcov(model)
  
  # Keep only variables of interest
  coefs_sub <- coefs[vars]
  vc_sub <- vc[vars, vars]
  
  # Build design matrix without intercept
  Xmat <- model.matrix(as.formula(paste("~", paste(vars, collapse = " + "), "-1")), 
                       data = grid_df)
  
  # Linear predictor
  lp <- as.vector(Xmat %*% coefs_sub)
  
  # Standard errors of predictions
  lp_se <- sqrt(rowSums((Xmat %*% vc_sub) * Xmat))
  
  # Z value for CI
  zval <- qnorm((1 + conf_level) / 2)
  
  # Transform to probability scale
  grid_df$rel_sel       <- plogis(lp)
  grid_df$rel_sel_lower <- plogis(lp - zval * lp_se)
  grid_df$rel_sel_upper <- plogis(lp + zval * lp_se)
  grid_df$rel_sel_ci_width <- grid_df$rel_sel_upper - grid_df$rel_sel_lower
  
  # Normalized uncertainty
  grid_df$rel_sel_ci_width_norm <- with(grid_df,
                                        (rel_sel_ci_width - min(rel_sel_ci_width, na.rm = TRUE)) /
                                          (max(rel_sel_ci_width, na.rm = TRUE) - min(rel_sel_ci_width, na.rm = TRUE))
  )
  
  # Rasterize & mask predictions
  r_mean <- rasterFromXYZ(grid_df[, c("x", "y", "rel_sel")])
  r_mean <- raster::mask(raster::crop(r_mean, shape), shape)
  
  #r_uncert <- rasterFromXYZ(grid_df[, c("x", "y", "rel_sel_ci_width_norm")])
  r_uncert <- rasterFromXYZ(grid_df[, c("x", "y", "rel_sel_ci_width")])
  r_uncert <- raster::mask(raster::crop(r_uncert, shape), shape)
  
  # Convert to dataframes for plotting
  df_mean   <- as.data.frame(r_mean, xy = TRUE)
  names(df_mean)[3] <- "pred"
  
  df_uncert <- as.data.frame(r_uncert, xy = TRUE)
  names(df_uncert)[3] <- "uncert"
  
  return(list(mean = df_mean, uncertainty = df_uncert))
}


res15 <- predict_rsf_with_ci(
  model = d2015,
  grid_df = grid_df15,
  vars = c("distRivers", "distRoads", "elevation","WnoPdist", "slope", "Sdist","evi2015"),
  shape = Krugershape
)




















#2012
d2012nnona=na.omit(dead_white_2012n)
d2012= clogit(used ~distRivers + distRoads 
              + elevation 
              #+ Edist 
              + WnoPdist
              + WPdist + Sdist
              + slope
              + evi2012
              #+ strata(stratum)
              , method = "approximate"
              , data = d2012nnona,
              na.action = "na.fail")
summary(d2012)


vif2012=car::vif(d2012)
vif2012

#2013
d13nnona=na.omit(dead_white_20132)
d13= clogit(used ~distRivers + distRoads 
            + elevation 
            #+Edist 
            + WnoPdist
            + WPdist + Sdist
            + slope
            + evi2013
            #+ strata(stratum)
            , data = d13nnona,
            method="approximate",
            na.action = "na.fail")
summary(d13)


vif2013=car::vif(d2013)
vif2013

#2014
d2014nnona=na.omit(dead_white_2014n)
d14= clogit(used ~distRivers + distRoads 
            + elevation 
            #+Edist 
            + WnoPdist
            + WPdist + Sdist
            + slope
            + evi2014
            #+ strata(stratum)
            ,method="approximate",
            data = d2014nnona,
            na.action = "na.fail")
summary(d14)


vif2014=car::vif(d2014)
vif2014

#2015
d2015nnona=na.omit(dead_white_2015n)
d15= clogit(used ~distRivers + distRoads 
            + elevation 
            #+Edist 
            + WnoPdist
            + WPdist + Sdist
            + slope
            + evi2015
            #+ strata(stratum)
            , data = d2015nnona,
            method="approximate",
            na.action = "na.fail")
summary(d15)


vif2015=car::vif(d2015)
vif2015

#2016
d2016nnona=na.omit(dead_white_2016n)
d2016= clogit(used ~distRivers + distRoads 
              + elevation 
              #+Edist 
              + WnoPdist
              + WPdist + Sdist
              + slope
              + evi2016
              #+ strata(stratum)
              , data = d2016nnona,
              method="approximate",
              na.action = "na.fail")
summary(d2016)


vif2016=car::vif(d2016)
vif2016

#2017
d2017nnona=na.omit(dead_white_2017n)
d2017= clogit(used ~distRivers + distRoads 
              + elevation 
              #+Edist 
              + WnoPdist
              + WPdist + Sdist
              + slope
              + evi2017
              #+ strata(stratum)
              , data = d2017nnona,
              method="approximate",
              na.action = "na.fail")
summary(d2017)


vif2017=car::vif(d2017)
vif2017


predict_rsf_with_ci <- function(model, grid_df, vars, shape, conf_level = 0.95) {
  # Extract coefficients and covariance
  coefs <- coef(model)
  vc <- vcov(model)
  
  # Keep only variables of interest
  coefs_sub <- coefs[vars]
  vc_sub <- vc[vars, vars]
  
  # Build design matrix without intercept
  Xmat <- model.matrix(as.formula(paste("~", paste(vars, collapse = " + "), "-1")), 
                       data = grid_df)
  
  # Linear predictor
  lp <- as.vector(Xmat %*% coefs_sub)
  
  # Standard errors of predictions
  lp_se <- sqrt(rowSums((Xmat %*% vc_sub) * Xmat))
  
  # Z value for CI
  zval <- qnorm((1 + conf_level) / 2)
  
  # Transform to probability scale
  grid_df$rel_sel       <- plogis(lp)
  grid_df$rel_sel_lower <- plogis(lp - zval * lp_se)
  grid_df$rel_sel_upper <- plogis(lp + zval * lp_se)
  grid_df$rel_sel_ci_width <- grid_df$rel_sel_upper - grid_df$rel_sel_lower
  
  # Normalized uncertainty
  grid_df$rel_sel_ci_width_norm <- with(grid_df,
                                        (rel_sel_ci_width - min(rel_sel_ci_width, na.rm = TRUE)) /
                                          (max(rel_sel_ci_width, na.rm = TRUE) - min(rel_sel_ci_width, na.rm = TRUE))
  )
  
  # Rasterize & mask predictions
  r_mean <- rasterFromXYZ(grid_df[, c("x", "y", "rel_sel")])
  r_mean <- raster::mask(raster::crop(r_mean, shape), shape)
  
  #r_uncert <- rasterFromXYZ(grid_df[, c("x", "y", "rel_sel_ci_width_norm")])
  r_uncert <- rasterFromXYZ(grid_df[, c("x", "y", "rel_sel_ci_width")])
  r_uncert <- raster::mask(raster::crop(r_uncert, shape), shape)
  
  # Convert to dataframes for plotting
  df_mean   <- as.data.frame(r_mean, xy = TRUE)
  names(df_mean)[3] <- "pred"
  
  df_uncert <- as.data.frame(r_uncert, xy = TRUE)
  names(df_uncert)[3] <- "uncert"
  
  return(list(mean = df_mean, uncertainty = df_uncert))
}




#2011


res11 <- predict_rsf_with_ci(
  model = d2011,
  grid_df = grid_df11,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2011"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res11$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res11$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)



#2012



res12 <- predict_rsf_with_ci(
  model = d2012,
  grid_df = grid_df12,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2012"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res12$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res12$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)







#2013



res13 <- predict_rsf_with_ci(
  model = d13,
  grid_df = grid_df13,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2013"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res13$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res13$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)



#2014



res14 <- predict_rsf_with_ci(
  model = d14,
  grid_df = grid_df14,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2014"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res14$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res14$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)



#2015


res15 <- predict_rsf_with_ci(
  model = d15,
  grid_df = grid_df15,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2015"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res15$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res15$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)



#2016


res16 <- predict_rsf_with_ci(
  model = d2016,
  grid_df = grid_df16,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2016"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res16$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res16$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)


#2017


res17 <- predict_rsf_with_ci(
  model = d2017,
  grid_df = grid_df17,
  vars = c("distRivers","distRoads","elevation", "WnoPdist","WPdist", "Sdist" ,"slope", "evi2017"),
  shape = Krugershape
)

# Plot mean prediction
p1 <- ggplot(res17$mean, aes(x = x, y = y, fill = pred)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Mean Relative\nSelection", na.value = "white") +
  coord_equal() + theme_minimal()

# Plot normalized uncertainty
p2_norm <- ggplot(res17$uncert, aes(x = x, y = y, fill = uncert)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Normalized\n95% CI Width", na.value = "white", limits = c(0,1)) +
  coord_equal() + theme_minimal()

# Show side-by-side
gridExtra::grid.arrange(p1, p2_norm,  ncol = 2)